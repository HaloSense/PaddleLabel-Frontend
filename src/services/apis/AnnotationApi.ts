/* tslint:disable */
/* eslint-disable */
/**
 * PP-Label API Spec
 * Back end APIs for PP-Label
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: me@linhan.email
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import { Annotation, AnnotationFromJSON, AnnotationToJSON } from '../models';

export interface AnnotationsAnnotationIdDeleteRequest {
  annotationId: number;
}

export interface AnnotationsAnnotationIdGetRequest {
  annotationId: number;
}

export interface AnnotationsAnnotationIdPutRequest {
  annotationId: number;
  annotation: Annotation;
}

export interface AnnotationsPostRequest {
  annotation: Annotation;
  requestId?: string;
}

/**
 *
 */
export class AnnotationApi extends runtime.BaseAPI {
  /**
   * Delete an annotation
   * Delete an annotation
   */
  async annotationsAnnotationIdDeleteRaw(
    requestParameters: AnnotationsAnnotationIdDeleteRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.annotationId === null || requestParameters.annotationId === undefined) {
      throw new runtime.RequiredError(
        'annotationId',
        'Required parameter requestParameters.annotationId was null or undefined when calling annotationsAnnotationIdDelete.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/annotations/{annotation_id}`.replace(
          `{${'annotation_id'}}`,
          encodeURIComponent(String(requestParameters.annotationId)),
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete an annotation
   * Delete an annotation
   */
  async annotationsAnnotationIdDelete(
    annotationId: number,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.annotationsAnnotationIdDeleteRaw({ annotationId: annotationId }, initOverrides);
  }

  /**
   * Get info of a specific annotation
   */
  async annotationsAnnotationIdGetRaw(
    requestParameters: AnnotationsAnnotationIdGetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Annotation>> {
    if (requestParameters.annotationId === null || requestParameters.annotationId === undefined) {
      throw new runtime.RequiredError(
        'annotationId',
        'Required parameter requestParameters.annotationId was null or undefined when calling annotationsAnnotationIdGet.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/annotations/{annotation_id}`.replace(
          `{${'annotation_id'}}`,
          encodeURIComponent(String(requestParameters.annotationId)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AnnotationFromJSON(jsonValue));
  }

  /**
   * Get info of a specific annotation
   */
  async annotationsAnnotationIdGet(
    annotationId: number,
    initOverrides?: RequestInit,
  ): Promise<Annotation> {
    const response = await this.annotationsAnnotationIdGetRaw(
      { annotationId: annotationId },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Edit annotation. Provide key value pair to change one value only. Provide all changed values to change multiple. Empty string will be set. Leave values don\'t intend to change out of request body.
   * Edit annotation
   */
  async annotationsAnnotationIdPutRaw(
    requestParameters: AnnotationsAnnotationIdPutRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Annotation>> {
    if (requestParameters.annotationId === null || requestParameters.annotationId === undefined) {
      throw new runtime.RequiredError(
        'annotationId',
        'Required parameter requestParameters.annotationId was null or undefined when calling annotationsAnnotationIdPut.',
      );
    }

    if (requestParameters.annotation === null || requestParameters.annotation === undefined) {
      throw new runtime.RequiredError(
        'annotation',
        'Required parameter requestParameters.annotation was null or undefined when calling annotationsAnnotationIdPut.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/annotations/{annotation_id}`.replace(
          `{${'annotation_id'}}`,
          encodeURIComponent(String(requestParameters.annotationId)),
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: AnnotationToJSON(requestParameters.annotation),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AnnotationFromJSON(jsonValue));
  }

  /**
   * Edit annotation. Provide key value pair to change one value only. Provide all changed values to change multiple. Empty string will be set. Leave values don\'t intend to change out of request body.
   * Edit annotation
   */
  async annotationsAnnotationIdPut(
    annotationId: number,
    annotation: Annotation,
    initOverrides?: RequestInit,
  ): Promise<Annotation> {
    const response = await this.annotationsAnnotationIdPutRaw(
      { annotationId: annotationId, annotation: annotation },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get all annotations, sort by last modified
   */
  async annotationsGetRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Array<Annotation>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/annotations/`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AnnotationFromJSON));
  }

  /**
   * Get all annotations, sort by last modified
   */
  async annotationsGet(initOverrides?: RequestInit): Promise<Array<Annotation>> {
    const response = await this.annotationsGetRaw(initOverrides);
    return await response.value();
  }

  /**
   * Create a new annotation
   */
  async annotationsPostRaw(
    requestParameters: AnnotationsPostRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Annotation>> {
    if (requestParameters.annotation === null || requestParameters.annotation === undefined) {
      throw new runtime.RequiredError(
        'annotation',
        'Required parameter requestParameters.annotation was null or undefined when calling annotationsPost.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (requestParameters.requestId !== undefined && requestParameters.requestId !== null) {
      headerParameters['request_id'] = String(requestParameters.requestId);
    }

    const response = await this.request(
      {
        path: `/annotations/`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: AnnotationToJSON(requestParameters.annotation),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AnnotationFromJSON(jsonValue));
  }

  /**
   * Create a new annotation
   */
  async annotationsPost(
    annotation: Annotation,
    requestId?: string,
    initOverrides?: RequestInit,
  ): Promise<Annotation> {
    const response = await this.annotationsPostRaw(
      { annotation: annotation, requestId: requestId },
      initOverrides,
    );
    return await response.value();
  }
}
