/* tslint:disable */
/* eslint-disable */
/**
 * PP-Label API Spec
 * Back end APIs for PP-Label
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: me@linhan.email
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import {
  Annotation,
  AnnotationFromJSON,
  AnnotationToJSON,
  InlineObject,
  InlineObjectFromJSON,
  InlineObjectToJSON,
  InlineObject1,
  InlineObject1FromJSON,
  InlineObject1ToJSON,
  InlineObject2,
  InlineObject2FromJSON,
  InlineObject2ToJSON,
  InlineResponse200,
  InlineResponse200FromJSON,
  InlineResponse200ToJSON,
  InlineResponse2001,
  InlineResponse2001FromJSON,
  InlineResponse2001ToJSON,
  Label,
  LabelFromJSON,
  LabelToJSON,
  Project,
  ProjectFromJSON,
  ProjectToJSON,
  Tag,
  TagFromJSON,
  TagToJSON,
  Task,
  TaskFromJSON,
  TaskToJSON,
} from '../models';

export interface CreateRequest {
  project: Project;
  requestId?: string;
}

export interface ExportDatasetRequest {
  projectId: string;
  inlineObject1?: InlineObject1;
}

export interface GetRequest {
  projectId: string;
  requestId?: string;
}

export interface GetAllRequest {
  requestId?: string;
}

export interface GetAnnotationsRequest {
  projectId: string;
}

export interface GetLabelsRequest {
  projectId: string;
}

export interface GetProgressRequest {
  projectId: string;
}

export interface GetTagsRequest {
  projectId: string;
}

export interface GetTasksRequest {
  projectId: string;
}

export interface ImportDatasetRequest {
  projectId: string;
  inlineObject2?: InlineObject2;
}

export interface RemoveRequest {
  projectId: string;
  requestId?: string;
}

export interface RemoveLabelsRequest {
  projectId: string;
}

export interface SetLabelsRequest {
  projectId: string;
  label?: Array<Label>;
}

export interface SplitDatasetRequest {
  projectId: string;
  inlineObject?: InlineObject;
}

export interface UpdateRequest {
  projectId: string;
  project: Project;
  requestId?: string;
}

/**
 *
 */
export class ProjectApi extends runtime.BaseAPI {
  /**
   * Create a new project
   */
  async createRaw(
    requestParameters: CreateRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Project>> {
    if (requestParameters.project === null || requestParameters.project === undefined) {
      throw new runtime.RequiredError(
        'project',
        'Required parameter requestParameters.project was null or undefined when calling create.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (requestParameters.requestId !== undefined && requestParameters.requestId !== null) {
      headerParameters['request_id'] = String(requestParameters.requestId);
    }

    const response = await this.request(
      {
        path: `/projects`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: ProjectToJSON(requestParameters.project),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
  }

  /**
   * Create a new project
   */
  async create(
    project: Project,
    requestId?: string,
    initOverrides?: RequestInit,
  ): Promise<Project> {
    const response = await this.createRaw(
      { project: project, requestId: requestId },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Export dataset to specified directory
   */
  async exportDatasetRaw(
    requestParameters: ExportDatasetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter requestParameters.projectId was null or undefined when calling exportDataset.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/projects/{project_id}/export`.replace(
          `{${'project_id'}}`,
          encodeURIComponent(String(requestParameters.projectId)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: InlineObject1ToJSON(requestParameters.inlineObject1),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Export dataset to specified directory
   */
  async exportDataset(
    projectId: string,
    inlineObject1?: InlineObject1,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.exportDatasetRaw(
      { projectId: projectId, inlineObject1: inlineObject1 },
      initOverrides,
    );
  }

  /**
   * Get info of a specific project
   */
  async getRaw(
    requestParameters: GetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Project>> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter requestParameters.projectId was null or undefined when calling get.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters.requestId !== undefined && requestParameters.requestId !== null) {
      headerParameters['request_id'] = String(requestParameters.requestId);
    }

    const response = await this.request(
      {
        path: `/projects/{project_id}`.replace(
          `{${'project_id'}}`,
          encodeURIComponent(String(requestParameters.projectId)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
  }

  /**
   * Get info of a specific project
   */
  async get(projectId: string, requestId?: string, initOverrides?: RequestInit): Promise<Project> {
    const response = await this.getRaw(
      { projectId: projectId, requestId: requestId },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Read all projects, sort by last modify date
   */
  async getAllRaw(
    requestParameters: GetAllRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Array<Project>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters.requestId !== undefined && requestParameters.requestId !== null) {
      headerParameters['request_id'] = String(requestParameters.requestId);
    }

    const response = await this.request(
      {
        path: `/projects`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProjectFromJSON));
  }

  /**
   * Read all projects, sort by last modify date
   */
  async getAll(requestId?: string, initOverrides?: RequestInit): Promise<Array<Project>> {
    const response = await this.getAllRaw({ requestId: requestId }, initOverrides);
    return await response.value();
  }

  /**
   * Get all annotations under a project
   */
  async getAnnotationsRaw(
    requestParameters: GetAnnotationsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Array<Annotation>>> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter requestParameters.projectId was null or undefined when calling getAnnotations.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/projects/{project_id}/annotations`.replace(
          `{${'project_id'}}`,
          encodeURIComponent(String(requestParameters.projectId)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AnnotationFromJSON));
  }

  /**
   * Get all annotations under a project
   */
  async getAnnotations(projectId: string, initOverrides?: RequestInit): Promise<Array<Annotation>> {
    const response = await this.getAnnotationsRaw({ projectId: projectId }, initOverrides);
    return await response.value();
  }

  /**
   * Get all labels under a project
   */
  async getLabelsRaw(
    requestParameters: GetLabelsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Array<Label>>> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter requestParameters.projectId was null or undefined when calling getLabels.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/projects/{project_id}/labels`.replace(
          `{${'project_id'}}`,
          encodeURIComponent(String(requestParameters.projectId)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LabelFromJSON));
  }

  /**
   * Get all labels under a project
   */
  async getLabels(projectId: string, initOverrides?: RequestInit): Promise<Array<Label>> {
    const response = await this.getLabelsRaw({ projectId: projectId }, initOverrides);
    return await response.value();
  }

  /**
   * Get project progress
   */
  async getProgressRaw(
    requestParameters: GetProgressRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<InlineResponse200>> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter requestParameters.projectId was null or undefined when calling getProgress.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/projects/{project_id}/progress`.replace(
          `{${'project_id'}}`,
          encodeURIComponent(String(requestParameters.projectId)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InlineResponse200FromJSON(jsonValue),
    );
  }

  /**
   * Get project progress
   */
  async getProgress(projectId: string, initOverrides?: RequestInit): Promise<InlineResponse200> {
    const response = await this.getProgressRaw({ projectId: projectId }, initOverrides);
    return await response.value();
  }

  /**
   * Get all tags under a project
   */
  async getTagsRaw(
    requestParameters: GetTagsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Array<Tag>>> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter requestParameters.projectId was null or undefined when calling getTags.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/projects/{project_id}/tags`.replace(
          `{${'project_id'}}`,
          encodeURIComponent(String(requestParameters.projectId)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TagFromJSON));
  }

  /**
   * Get all tags under a project
   */
  async getTags(projectId: string, initOverrides?: RequestInit): Promise<Array<Tag>> {
    const response = await this.getTagsRaw({ projectId: projectId }, initOverrides);
    return await response.value();
  }

  /**
   * Get all tasks under a project
   */
  async getTasksRaw(
    requestParameters: GetTasksRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Array<Task>>> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter requestParameters.projectId was null or undefined when calling getTasks.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/projects/{project_id}/tasks`.replace(
          `{${'project_id'}}`,
          encodeURIComponent(String(requestParameters.projectId)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TaskFromJSON));
  }

  /**
   * Get all tasks under a project
   */
  async getTasks(projectId: string, initOverrides?: RequestInit): Promise<Array<Task>> {
    const response = await this.getTasksRaw({ projectId: projectId }, initOverrides);
    return await response.value();
  }

  /**
   */
  async importDatasetRaw(
    requestParameters: ImportDatasetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter requestParameters.projectId was null or undefined when calling importDataset.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/projects/{project_id}/import`.replace(
          `{${'project_id'}}`,
          encodeURIComponent(String(requestParameters.projectId)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: InlineObject2ToJSON(requestParameters.inlineObject2),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async importDataset(
    projectId: string,
    inlineObject2?: InlineObject2,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.importDatasetRaw(
      { projectId: projectId, inlineObject2: inlineObject2 },
      initOverrides,
    );
  }

  /**
   * Delete a project record and ALL TASKS RECORDS under the project. Won\'t delete file on file system
   * Delete a project record and ALL TASKS RECORDS under the project.
   */
  async removeRaw(
    requestParameters: RemoveRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter requestParameters.projectId was null or undefined when calling remove.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters.requestId !== undefined && requestParameters.requestId !== null) {
      headerParameters['request_id'] = String(requestParameters.requestId);
    }

    const response = await this.request(
      {
        path: `/projects/{project_id}`.replace(
          `{${'project_id'}}`,
          encodeURIComponent(String(requestParameters.projectId)),
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete a project record and ALL TASKS RECORDS under the project. Won\'t delete file on file system
   * Delete a project record and ALL TASKS RECORDS under the project.
   */
  async remove(projectId: string, requestId?: string, initOverrides?: RequestInit): Promise<void> {
    await this.removeRaw({ projectId: projectId, requestId: requestId }, initOverrides);
  }

  /**
   * Delete all labels under a project
   */
  async removeLabelsRaw(
    requestParameters: RemoveLabelsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter requestParameters.projectId was null or undefined when calling removeLabels.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/projects/{project_id}/labels`.replace(
          `{${'project_id'}}`,
          encodeURIComponent(String(requestParameters.projectId)),
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete all labels under a project
   */
  async removeLabels(projectId: string, initOverrides?: RequestInit): Promise<void> {
    await this.removeLabelsRaw({ projectId: projectId }, initOverrides);
  }

  /**
   * Set all labels under a project, will delete previous labels
   */
  async setLabelsRaw(
    requestParameters: SetLabelsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Array<Label>>> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter requestParameters.projectId was null or undefined when calling setLabels.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/projects/{project_id}/labels`.replace(
          `{${'project_id'}}`,
          encodeURIComponent(String(requestParameters.projectId)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.label.map(LabelToJSON),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LabelFromJSON));
  }

  /**
   * Set all labels under a project, will delete previous labels
   */
  async setLabels(
    projectId: string,
    label?: Array<Label>,
    initOverrides?: RequestInit,
  ): Promise<Array<Label>> {
    const response = await this.setLabelsRaw({ projectId: projectId, label: label }, initOverrides);
    return await response.value();
  }

  /**
   * Split this project\'s data into train, validation and test dataset.
   */
  async splitDatasetRaw(
    requestParameters: SplitDatasetRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<InlineResponse2001>> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter requestParameters.projectId was null or undefined when calling splitDataset.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/projects/{project_id}/split`.replace(
          `{${'project_id'}}`,
          encodeURIComponent(String(requestParameters.projectId)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: InlineObjectToJSON(requestParameters.inlineObject),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InlineResponse2001FromJSON(jsonValue),
    );
  }

  /**
   * Split this project\'s data into train, validation and test dataset.
   */
  async splitDataset(
    projectId: string,
    inlineObject?: InlineObject,
    initOverrides?: RequestInit,
  ): Promise<InlineResponse2001> {
    const response = await this.splitDatasetRaw(
      { projectId: projectId, inlineObject: inlineObject },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Edit multiple project properties. Empty strings will be set. Properties not in request body won\'t be changed
   * Edit multiple project properties
   */
  async updateRaw(
    requestParameters: UpdateRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Project>> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter requestParameters.projectId was null or undefined when calling update.',
      );
    }

    if (requestParameters.project === null || requestParameters.project === undefined) {
      throw new runtime.RequiredError(
        'project',
        'Required parameter requestParameters.project was null or undefined when calling update.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (requestParameters.requestId !== undefined && requestParameters.requestId !== null) {
      headerParameters['request_id'] = String(requestParameters.requestId);
    }

    const response = await this.request(
      {
        path: `/projects/{project_id}`.replace(
          `{${'project_id'}}`,
          encodeURIComponent(String(requestParameters.projectId)),
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: ProjectToJSON(requestParameters.project),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
  }

  /**
   * Edit multiple project properties. Empty strings will be set. Properties not in request body won\'t be changed
   * Edit multiple project properties
   */
  async update(
    projectId: string,
    project: Project,
    requestId?: string,
    initOverrides?: RequestInit,
  ): Promise<Project> {
    const response = await this.updateRaw(
      { projectId: projectId, project: project, requestId: requestId },
      initOverrides,
    );
    return await response.value();
  }
}
